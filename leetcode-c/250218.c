// 爬楼梯（进阶）

// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
// 每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？
// 注意：给定 n 是一个正整数。

// 输入描述
// 输入共一行，包含两个正整数，分别表示n, m
// 输出描述
// 输出一个整数，表示爬到楼顶的方法数。

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int n, m, result;
    scanf("%d %d", &n, &m);
    // 排列问题，动态规划
    // dp[i]:爬到第i个台阶的方法数
    int *dp = malloc(sizeof(int) * (n + 1));
    // 初始化
    for (int i = 0; i <= n; i++)
    {
        dp[i] = 0;
    }
    dp[0] = 1;

    // 遍历
    for (int i = 0; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (i - j >= 0)
                dp[i] += dp[i - j];
        }
    }

    for (int i = 0; i <= n; i++)
    {
        printf("%d ", dp[i]);
    }
    printf("\n%d", dp[n]);
}

// 其实本质上是个 完全背包问题

// dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法

// dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]

// 这是背包里求排列问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！
// 所以需将target放在外循环，将nums放在内循环。
// 每一步可以走多次，这是完全背包，内循环需要从前向后遍历。