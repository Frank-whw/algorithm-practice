// 3679. 使库存平衡的最少丢弃次数
// 中等

// 提示
// 给你两个整数 w 和 m，以及一个整数数组 arrivals，其中 arrivals[i] 表示第 i 天到达的物品类型（天数从 1 开始编号）。

// 物品的管理遵循以下规则：

// 每个到达的物品可以被 保留 或 丢弃 ，物品只能在到达当天被丢弃。
// 对于每一天 i，考虑天数范围为 [max(1, i - w + 1), i]（也就是直到第 i 天为止最近的 w 天）：
// 对于 任何 这样的时间窗口，在被保留的到达物品中，每种类型最多只能出现 m 次。
// 如果在第 i 天保留该到达物品会导致其类型在该窗口中出现次数 超过 m 次，那么该物品必须被丢弃。
// 返回为满足每个 w 天的窗口中每种类型最多出现 m 次，最少 需要丢弃的物品数量。

#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        unordered_map<int, int> cnt;
        int res = 0;
        for(int i = 0; i < arrivals.size(); i++){
            int &x = arrivals[i];
            if(cnt[x] == m){
                x = 0;
                res ++;
            }else{
                cnt[x]++;
            }
            int left = i + 1 - w;
            if(left >= 0){
                cnt[arrivals[left]]--;
            }
        }
        return res;
    }
};

/* 
1. 核心贪心逻辑：要实现“最少丢弃”，必须遵循“能留必留，仅超标时丢弃”的原则——每遇到一个物品，优先尝试保留，不提前丢弃（提前丢弃会不必要减少保留量，导致丢弃总数增多）；只有当“保留后，该物品在最近w天窗口内的数量超过m”时，才不得不丢弃，这是局部最优选择，最终能实现全局最少丢弃。

​

2. 滑动窗口的作用：为了判断“当前保留是否超标”，需要实时维护“最近w天窗口”内未丢弃物品的频率——用哈希表记录窗口内各物品的保留次数，确保统计的是“当前有效窗口”的频率，而非所有历史物品。

​

3. 丢弃标记的设计：因题目中物品类型无0，用“0”作为虚拟标记——当物品被丢弃时，将原数组中该物品位置设为0，后续滑动窗口移除左边界物品时，若左边界是0（说明当初已丢弃，未计入频率），则无需处理哈希表；若非0（说明当初保留，计入过频率），则需将哈希表中该物品的频率减1，保证频率统计始终对应当前窗口。

*/
